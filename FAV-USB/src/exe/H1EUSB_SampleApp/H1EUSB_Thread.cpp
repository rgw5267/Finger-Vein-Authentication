#include "StdAfx.h"
#include <process.h>
#include "H1EUSB_Thread.h"
/********************************************************************************************/
/* CA2GObjThreadクラスプログラム															*/
/*------------------------------------------------------------------------------------------*/
/*[作成]		<作成者><作成日><バージョン‐リビジョン>									*/
/*				<白戸><20120110>　Initial Version.                                          */
/*------------------------------------------------------------------------------------------*/
/*[修正来歴]	<修正者><修正日><バージョン‐リビジョン><障害管理番号><修正内容>	    	*/
/*                                                                          				*/
/********************************************************************************************/
/********************************************************************************************/
/*[メソッド名] CA2GObjThreadクラスのコンストラクタ											*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]		CA2GObjThread(void)															*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		コンストラクタ処理															*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		なし																		*/
/********************************************************************************************/
CA2GObjThread::CA2GObjThread(LPVOID pObj, PA2GOBJTHREADPROCS pA2gObjThreadProcs)
{
	m_pObjThreadProcs = pObj;
	m_A2gObjTheradProcs = *pA2gObjThreadProcs;
	CA2GObjInitialize();
}

/********************************************************************************************/
/*[メソッド名] CA2GObjThreadクラスのコンストラクタ											*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]		CA2GObjThread(void)															*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		コンストラクタ処理															*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		なし																		*/
/********************************************************************************************/
CA2GObjThread::CA2GObjThread(void)
{
	m_pObjThreadProcs = 0;
	ZeroMemory(&m_A2gObjTheradProcs, sizeof(m_A2gObjTheradProcs));
	CA2GObjInitialize();

}

/********************************************************************************************/
/*[メソッド名] CA2GObjThreadクラスのデストラクタ											*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]		~CA2GEndpoint(void)															*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		デストラクタ処理															*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		なし																		*/
/********************************************************************************************/
CA2GObjThread::~CA2GObjThread(void)
{
	EndThread();
}


/********************************************************************************************/
/*[メソッド名] CA2GObjThreadクラスの初期化処理												*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]		CA2GObjThread(void)															*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		CA2GObjThreadクラスの初期化処理												*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		なし																		*/
/********************************************************************************************/
void CA2GObjThread::CA2GObjInitialize(void)
{
	DWORD	dw;
	m_dwEvents	= 0;
	m_hEPThread	= 0;
	//イベントコールバックテーブルを初期化
	for(dw=0; dw<THREAD_MAX_EVENTS; dw++){
		m_EventInfo.hEventHandles[dw]	= 0;
		m_EventCallBacks[dw].proc = 0;
		m_EventCallBacks[dw].pObj = 0;
	}
	//イベントタイムアウトコールバックテーブルを初期化
	m_EventTOutCallBacks.proc	= 0;
	m_EventTOutCallBacks.pObj	= 0;
	//メッセージコールバックを初期化
	m_MsgCallBack.Proc		= 0;
	m_MsgCallBack.pObj		= 0;

	m_dwThreadLoopCycle = THREAD_EVENTS_CYCLE;		//スレッドループ周期の初期値

}

/********************************************************************************************/
/*[メソッド名] スレッドの生成																*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]		CreateThread(int nPriority);												*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		デストラクタ処理															*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		正常終了：H1USB_OK															*/
/********************************************************************************************/
int CA2GObjThread::CreateThread(int nPriority)
{
	//スレッドの起動
	m_hEPThread = (HANDLE)_beginthreadex(NULL, 0, &A2GObjThreadStab, this, 0, &m_uEPThreadID);

	if(m_hEPThread != 0){
		//スレッドの優先順位をセットする。
		SetThreadPriority(m_hEPThread , nPriority);

		//スレッドが起動されるまで待機する。
		DWORD dwExitCode;
		dwExitCode = 0;
		while(dwExitCode != STILL_ACTIVE){
			GetExitCodeThread(m_hEPThread, &dwExitCode);
			Sleep(100);
		}
	}
	else{
		//スレッドの起動に失敗した。
		return H1USB_ERR_CREATETHREAD;

	}
	return H1USB_OK;
}



/********************************************************************************************/
/*[メソッド名] スレッドの終了																*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]		EndThread(void);															*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		スレッドの終了処理を行う													*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		正常終了：H1USB_OK															*/
/********************************************************************************************/
int CA2GObjThread::EndThread(void)
{
	DWORD	dwResult;

	if(m_hEPThread){
		//終了メッセージを送信
		PostThreadMessage(m_uEPThreadID, WM_QUIT, 0, 0);

		//スレッドの終了待ち
		dwResult = WaitForSingleObject(m_hEPThread, THREAD_END_TIMEOUTS);
		if(dwResult == WAIT_TIMEOUT){
			//強制終了
			TerminateThread(m_hEPThread, THREAD_ENDCODE_FORCED);
		}
		//ハンドルクローズ
		CloseHandle(m_hEPThread);
		m_hEPThread = 0;
	}
	return H1USB_OK;
}

/********************************************************************************************/
/*[メソッド名] CA2GObjThreadクラスのコンストラクタ											*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]		SetThreadProcs(LPVOID pObj, PA2GOBJTHREADPROCS pA2gObjThreadProcs)			*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		コンストラクタ処理															*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		なし																		*/
/********************************************************************************************/
void CA2GObjThread::SetThreadProcs(LPVOID pObj, PA2GOBJTHREADPROCS pA2gObjThreadProcs)
{
	m_pObjThreadProcs	= pObj;
	m_A2gObjTheradProcs	= *pA2gObjThreadProcs;
}



/********************************************************************************************/
/*[メソッド名] メッセージPROCの登録															*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]		int SetMessageProc(A2GOBJ_MSG_PROC A2gMsgProc, LPVOID pObj);				*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		メッセージPROCの登録処理を行う												*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		正常終了：H1USB_OK															*/
/********************************************************************************************/
int CA2GObjThread::SetMessageProc(A2GOBJ_MSG_PROC A2gMsgProc, LPVOID pObj)
{
	m_MsgCallBack.Proc	= A2gMsgProc;
	m_MsgCallBack.pObj	= pObj;

	return H1USB_OK;
}

/********************************************************************************************/
/*[メソッド名] イベントPROCの登録															*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]	int SetEventProc(HANDLE hEvent, HANDLE hDevice,									*/
/*								A2GOBJ_EVENT_PROC A2gEventProc, LPVOID pObj);				*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		イベントPROCの登録の登録処理を行う											*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		正常終了：AL2P_SUCCESS														*/
/********************************************************************************************/
int CA2GObjThread::SetEventProc(HANDLE hEvent, HANDLE hDevice, A2GOBJ_EVENT_PROC A2gEventProc, LPVOID pObj)
{

	if(m_dwEvents >= THREAD_MAX_EVENTS){
		//登録できるイベントの最大数を超えた。
		return H1USB_ERR_MAXEVENTS;
	}
	m_EventInfo.hEventHandles[m_dwEvents]	= hEvent;
	m_EventCallBacks[m_dwEvents].proc = A2gEventProc;
	m_EventCallBacks[m_dwEvents].pObj = pObj;
	m_dwEvents++;

	return H1USB_OK;
}

/********************************************************************************************/
/*[メソッド名] イベントPROCの登録															*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]	int SetEventTOutProc(A2GOBJ_EVENT_TIMEOUT_PROC A2gEventTOutProc, LPVOID pObj);	*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		イベントPROCの登録の登録処理を行う											*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		正常終了：H1USB_OK															*/
/********************************************************************************************/
int CA2GObjThread::SetEventTOutProc(A2GOBJ_EVENT_TIMEOUT_PROC A2gEventTOutProc, LPVOID pObj)
{
	m_EventTOutCallBacks.proc	= A2gEventTOutProc;
	m_EventTOutCallBacks.pObj	= pObj;
	return H1USB_OK;
}

/********************************************************************************************/
/*[メソッド名] スレッドループ周期セット														*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]	int SetThreadCycle(DWORD dwCycle);												*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		スレッドのループ周期をセットする。											*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		正常終了：H1USB_OK															*/
/********************************************************************************************/
int CA2GObjThread::SetThreadCycle(DWORD dwCycle)
{
	m_dwThreadLoopCycle = dwCycle;
	return H1USB_OK;
}


/********************************************************************************************/
/*[メソッド名] スレッドスタブ																*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]		DWORD WINAPI EPThreadStab(void* pParam)										*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		スレッドスタブ																*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		正常終了：H1USB_OK															*/
/********************************************************************************************/
UINT WINAPI CA2GObjThread::A2GObjThreadStab(void* pParam)
{
	UINT	ui;
	int		iResult;

	CA2GObjThread* pEp = (CA2GObjThread*)(pParam);

	//スレッド前処理
	iResult = pEp->A2GObjThreadBefor();
	//スレッドの実体をコール
	ui = pEp->A2GObjThread();
	//スレッド後処理
	iResult = pEp->A2GObjThreadBefor();
	//スレッドの終了
	_endthreadex(ui);
	return ui;
}

/********************************************************************************************/
/*[メソッド名] スレッド前呼び出し処理														*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]		UINT CA2GObjThread::A2GObjThreadBefor(void)									*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		スレッドのメッセージループ前呼び出し処理									*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		正常終了：H1USB_OK															*/
/********************************************************************************************/
int CA2GObjThread::A2GObjThreadBefor(void)
{	
	UINT uiResult;
	int iResult = H1USB_OK;

	if(m_A2gObjTheradProcs.A2GObjThreadBefor)
	{
		uiResult = m_A2gObjTheradProcs.A2GObjThreadBefor(m_pObjThreadProcs);
	}
	return iResult;
}

/********************************************************************************************/
/*[メソッド名] スレッドメッセージ呼び出し処理												*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]		UINT CA2GObjThread::A2GObjOnThread(void)									*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		スレッドのメッセージループ呼び出し処理										*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		正常終了：H1USB_OK															*/
/********************************************************************************************/
int CA2GObjThread::A2GObjOnThread(LPBOOL pOnEvnet)
{
	UINT uiResult;
	int iResult = H1USB_OK;

	if(m_A2gObjTheradProcs.A2GObjOnThread)
	{
		uiResult = m_A2gObjTheradProcs.A2GObjOnThread(m_pObjThreadProcs);
	}
	return iResult;
}

/********************************************************************************************/
/*[メソッド名] スレッド後呼び出し処理														*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]		UINT CA2GObjThread::A2GObjThreadAfter(void)									*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		スレッドのメッセージループ後呼び出し処理									*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		正常終了：H1USB_OK															*/
/********************************************************************************************/
int CA2GObjThread::A2GObjThreadAfter(void)
{
	UINT uiResult;
	int iResult = H1USB_OK;

	if(m_A2gObjTheradProcs.A2GObjThreadAfter)
	{
		uiResult = m_A2gObjTheradProcs.A2GObjThreadAfter(m_pObjThreadProcs);
	}
	return iResult;
}



/********************************************************************************************/
/*[メソッド名] スレッドの実体																*/
/*------------------------------------------------------------------------------------------*/
/*[宣言]		UINT CA2GObjThread::A2GObjThread(void)										*/
/*																							*/
/*------------------------------------------------------------------------------------------*/
/*[内容]		スレッド処理																*/
/*------------------------------------------------------------------------------------------*/
/*[戻り値]		正常終了：H1USB_OK															*/
/********************************************************************************************/
UINT CA2GObjThread::A2GObjThread(void)
{
	BOOL						bResult;
	BOOL						bEnable;
	MSG							msg;
	LRESULT						lResult;
	DWORD						dwWaitObject;
	DWORD						dwEvent;
	A2GOBJ_MSG_PROC				A2gMsgProc;		
	A2GOBJ_EVENT_PROC			A2gEventProc;
	A2GOBJ_EVENT_TIMEOUT_PROC	A2gEventTOutProc;
	int							iResult;
	BOOL						bOnEvent;
	DWORD						dwError;

	A2gMsgProc			= m_MsgCallBack.Proc;
	A2gEventTOutProc	= m_EventTOutCallBacks.proc;


	bEnable		=TRUE;
	bOnEvent	=FALSE;
	//スレッドメッセージループ
	while(bEnable)
	{
		//メッセージ処理
		bResult = PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
		if(bResult){
			if(A2gMsgProc){
				//上位のクラスからメンバーが登録されていれば呼び出す。
				lResult = A2gMsgProc(msg.message, msg.wParam, msg.lParam, m_MsgCallBack.pObj);
			}
			switch(msg.message)
			{
			case WM_QUIT:
				bEnable = FALSE;
				continue;
			default:
				break;
			}
		}

		//OnThread処理
		if(!bOnEvent){
			//イベント処理中でなければ呼び出す。
			iResult = A2GObjOnThread(&bOnEvent);
		}

		if(m_dwEvents){
			//イベント待ち
			if(!bResult)
			{
				dwError = GetLastError();
				if(dwError == ERROR_IO_PENDING){
					do {
						dwWaitObject = WaitForSingleObject(m_EventInfo.hEventHandles[0], INFINITE);
					}while(dwWaitObject == WAIT_TIMEOUT);
				}

			};

			dwWaitObject = WaitForMultipleObjects(m_dwEvents, m_EventInfo.hEventHandles, FALSE, m_dwThreadLoopCycle);
			if(dwWaitObject ==WAIT_TIMEOUT){
				//イベントタイムアウト処理
				if(A2gEventTOutProc){
					//イベントタイムアウト処理をコールバック
					lResult = A2gEventTOutProc(m_EventTOutCallBacks.pObj);
				}
			}
			else{
				//イベント処理
				dwEvent = WAIT_OBJECT_0-dwWaitObject;
				A2gEventProc = m_EventCallBacks[dwEvent].proc;
				//イベント処理をコールバック
				lResult = A2gEventProc(dwEvent, m_EventCallBacks[dwEvent].pObj);

				//イベント処理を終了
				bOnEvent = FALSE;
				//スレッドスリープ
				Sleep(m_dwThreadLoopCycle);
			}
		}
		else{
			//スレッドスリープ
			Sleep(m_dwThreadLoopCycle);
		}


#ifdef _DEBUG		
	//Beep(880, 100);
#endif

	}
	return THREAD_ENDCODE_NORMAL;
}

